# 객체 지향 설계 5원칙 - SOLID 
<br>

작성일자 : 2021-10-03

내용 :  스프링 입문을 위한 자바 객체 지향의 원리와 이해 서적 공부

<br><br>

## **객체 지향 설계(OOP : Object Oriented Design)**

- 객체 지향 언어의 특성을 잘 이용해 객체 지향 프로그램을 올바르게 설계해 나가는 방법이나 원칙
- 응집도는 높이고 (High Cohesion), 결합도는 낮추라(Loose Coupling)는 고전원직을 객체 지향의 관점에서 재정립

<br><br>

## **1. SRP(Single Responsibility Principle) : 단일 책임 원칙**

- "어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다" - 로버트 C. 마틴

- 역할과 책임에 따라 분리하여 각각 하나의 역할과 책임만 갖도록 한다.

- 객체 지향 4대 원칙(캡슐화,상속,추상화,다형성) 중 모델링 과정인 추상화와 가장 관계가 깊다.

 <br>

  예시코드 - 속성이 SRP를 지키지 않은 경우 

``` java 
public class People{
    String miliatayNumber; // 군번
...
 
    public static void main(String[] args) {
        People boy = new People(); // 남자
        People girl = new People(); // 여자
        
        girl.miliatayNumber = "1578320321";
    }
}

```

여자가 절대로 군대에 가지 않는 다는 가정을 했을때 People 클래스 참조 변수인 girl 은 군번이 없음에도 군번 속성을 갖고 있어야한다...
이럴 경우에는 남자와 여자의 공통 속성을 사람클래스 속성으로 두고 여자, 남자 클래스는 사람 클래스를 상속받아 공통 속성을 갖고 차이점은 각자 구현하면 된다.  



​		예시코드 - 메서드가 SRP를 지키지 않은 경우



```java
public class Dog {
    final static Boolean man = true;
    final static Boolean woman = false;
    Boolean sex;
 
    void pee() {
        if (this.sex == man) {
            // 한쪽 다리를 들고 소변을 본다.
        } else {
            // 뒷다리 두 개를 굽혀 앉은 자세로 소변을 본다.
        }
    }
}
```



if를 사용하여 분기처리 하는건 단일 책임 원칙을 위배하는 것이다.



단일 책임 원칙을 적용해 코드를 리팩토링 해보자.

```JAVA
abstract class Dog {
    abstract void pee();
}
 
class ManDog extends Dog {
    @Override
    void pee() {
        // 한쪽 다리를 들고 소변을 본다
    }
}
 
class WomanDog extends Dog {
    @Override
    void pee() {
        // 뒷다리 두 개로 앉은 자세로 소변을 본다.
    }
}
```

<br>

> 나의 질문 
>
> 1. 나는 SRP를 잘 지켜 코드를 작성했는가? : 나는 썩은 코드를 작성해왔다...
>
> 2. 왜 SRP을 지켜야 할까? 
>    SRP를 지키지 않을 경우 대표적으로 두가지 문제를 유발할 수 있다.
>
>    - 첫번째는 소외가 생긴다. 
>      예를 들면 A라는 책임과 B라는 책임을 가지고 있는 클래스가 있는 경우
>      A만 필요로 하는 애플리케이션은 항상 B도 들고 다녀야한다. 들고 다니지만 사용하지 않는 소외가 생긴다.
>
>    - 불필요한 변경의 영향이 생긴다.  
>      예를 들면 Srp클래스가 있다. Srp클래스 내에는 a(), b()메서드가 있다. aa라는 어플리케이션은  Srp클래스를 사용하는데 그 중 a()메서드만을 사용한다. 
>
>      그런데 Srp클래스 에서 b() 메서드가 수정됐다.  aa어플리케이션은 사용하지도 않는 b()메서드때문에 다시 컴파일 하고 재배포 해야한다..
>
> 3. SRP에서 Responsibility는 뭔 책임을 의미하는 걸까??
>
>    - 여기에서 책임은 "변경을 위한 이유"이다.
>    - 만약에 하나의 클래스 변경을 위한 두가지 이상의 이유가 있다면 그 클래스는 한가지 이상의 책임을 가지고 있는 것이다.
>    - 예를 들면) 환율조정 어플리케이션과 이율관리 어플리케이션이 잔고 class를 사용한다.
>      이때 잔고 class가 변경된 이유가 2가지생긴다. 환율조정 어플리케이션때문이거나 이율관리 어플리케이션 때문이다. 이 경우 변경을 위한 이유가 2가지가 된다. 
>
>    출처: https://zdnet.co.kr/view/?no=00000039135552


<br><br>


## **2. OCP (Open Closed Principle) : 개방 폐쇄 원칙**

- "소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려있어야 하지만 변경에는 닫혀있어야 한다 " - 로버트 C.마틴
- 하나의 변화가 다른 곳에 연쇄적으로 변화를 일으키는 것을 방지하기위해 사용(유연성, 유지보수성, 확장성, 재사용성 up!!!)
- 아주 좋은 예시 1)  JDBC 
  - 데이터 베이스가 오라클에서 MySQL로 바뀌더라도 Connection을 설정하는 부분외에는 따로 수정할 필요가 없다.
  - JDBC 인터페이스 : 완충장치 
    자바어플리케이션은 주변 변화에 닫혀있다. DB를 교체한다는건 DB가 자신의 확장에는 열려있다.

![image-20211004210747166](https://user-images.githubusercontent.com/56250078/135857841-ae8f626a-026b-45a8-923e-e92947870b09.png)


<br>

- 아주 좋은 예시 2) 개발자의 소스코드와 운영체제별 JVM사이에는 목적파일이라는 완충장치가 있다.

  

  > 나의 질문 : 어떻게 OCP를 적용해서 설계하지?
  >
  > - 우선 변하는 것과 변하지 않는 것을 구분한다. 변하는 것은 변하기 쉽게 변하지 않는 것은 변하는 것에 영향을 받지 않도록 설계해야한다.
  >
  > - 두 모듈이 만나는 지점에 interface를 정의한다. interface는 변하는 것과 변하지 않는 모듈의 교차점으로 서로 보호하는 방죽 역할을 한다.
  >
  >   출처 : https://zdnet.co.kr/view/?no=00000039134727



<br><br>


## **3. LSP (Liskov Substitution Principle) : 리스코프 치환 원칙**

- "서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다." - 로버트 C.마틴

- 객체 지향의 상속의 조건을 복습하자

  - 하위 클래스 is a kind of 상위 클래스  - 하위 분류는 상위 분류의 한 종류이다.

  - 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스 할 수 잇어야 한다.
    예) AutoCloseable - 자동으로 닫힐 수 있어야 한다. ... (try with source 생각나네..)

  - 상속의 개념은 '계층도/조직도'가 아닌 분류도 라고 다시 공부했다.

    
   <img width="483" alt="20211004-212504941" src="https://user-images.githubusercontent.com/56250078/135858109-08d31038-b32a-4eae-b9ad-c9a986c8f8a5.png">
   <br>
    예) 아버지 딸래미 = new 딸();     

    ​		딸은 아버지다??     논리적으로 아주 이상하다 딸은 아버지다???....... 에???네???
    
    <br>   



   <img width="483" alt="20211004_221713" src="https://user-images.githubusercontent.com/56250078/135858220-d89f22e1-2c46-4f74-8cdf-ae8a55749ce3.png">
  

    예) 동물 펭수 = new 펭귄();      

    ​		펭귄은 동물의 한 종류이다.

    ​		펭수는 펭귄이다. 펭수는 동물이다.

<br>        

- "하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다."
- 리스코프 치환 원칙은 객체 지향의 상속이라는 특성을 올바르게 활용하면 자연스럽게 얻게 된다.

<br><br>



## **4. ISP (Interface Segregation Principle) : 인터페이스 분리 원칙**

- "클라이언트는 자신이 사용하지 않는 메서드에 의존관계를 맺으면 안된다." - 로버트 C.마틴
- 단일 책임 원칙(SRP)와 인터페이스분리 원칙(ISP)은 같은 문제에 대한 두가지 다른 해결책 (역할분리, 클래스분리)이다.
  책에 의하면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이라고 한다.. 왜지?

- 상위클래스는 풍성할 수록 좋고 인터페이스는 작을 수록 좋다.
  이유 : 상위클래스가 빈약할 경우 필요없는 형변환이 자주 일어나게 되면서 상속의 혜택이 줄어든다.
- 인터페이스는 그 역할에 충실한 최소한의 기능만 공개해라.
- ISP를 '하나의 일반적인 인터페이스보다는 여러개의 구체적인 인터페이스가 낫다.'
- 어떤 클래스를 이용하는 클라이언트가 여러개 있고, 이들이 해당 클래스의 특정 부분 집합만 사용한다면 이들을 따로 인터페이스로 빼내어 클라이언트가 기대하는 메시지만을 전달 할 수 있도록 하는것이다. 

<br>

- 예 )  복합기 기능을 제공하는 클래스의 클라이언트가 모든기능을 동시에 사용하는 경우는 거의 없다. 클라이언트에따라 프린터, 팩스, 복사 기능 중 하나를 이용한다. 프린터기능만 사용하는 클라이언트가 팩스기능의 변경으로 발생하는 문제의 영향을 받지 않도록 해야한다.

  

  <img width="300" alt="20211004_221818-1" src="https://user-images.githubusercontent.com/56250078/135858404-452cddf0-a909-4799-89d7-20703b038b06.png">  

  사용하지 않는 기능의 변화로 클라이언트가 영향을 받지 않으려면 범용의 인터페이스보다는 클라이언트에 특화된 인터페이스를 사용해야한다. ISP는 인터페이스를 클라이언트에 특화되도록 분리시키라는 원칙이기도 하다.

  <img width="300" alt="20211004_221828-2" src="https://user-images.githubusercontent.com/56250078/135858419-7f16aafa-d328-42c1-ad04-32b99a31c2bc.png">
  

 


  - 출처: https://defacto-standard.tistory.com/114


<br><br>


## **5. DIP (Dependency Inversion Principle) : 의존 역전 원칙**

- "고차원 모듈은 저차원 모듈에 의존하면 안된다."

- "추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다."

- "자주 변경되는 구체(Concrete)클래스에 의존하지 마라"   - 로버트 C.마틴

  == "자신보다 변하기 쉬운 것에 의존하지 마라"

- 예 ) **JDBC** - 각각의 DB 종류에 의존하다가 추상화된 인터페이스인 JDBC interface를 두어 의존 관계를 역전 시키고 변화에 영향을 받지 않게 함.

- 상위 클래스일 수록, interface일 수록, 추상 클래스일 수록 변할 가능성이 낮다. 하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스를 통해 의존해라


<br>  


>  나의 질문  
>
> - DIP 왜 사용해야 할까?  : 사용하지 않을 경우 자주 변하는 클래스에 의존 => 자주 변경될때마다 영향을 받게 되고 같이 수정하거나 재컴파일 해야한다.



<br><br>

## **+ Soc (Separation Of Concerns)** : 관심사의 분리

- 하나의 속성, 하나의 메서드, 하나의 클래스, 하나의 모듈 또는 하나의 패키지에는 하나의 관심사만 들어 있어야 한다.
- 관심사가 다르고 변화의 시기가 다르면 분리해야한다.


<br>

> 나의 질문 
>
> - Soc는 왜 적용해야 할까?
>
>   : Soc를 적용하면 자연스럽게 단일책임원칙(SRP),인터페이스분리원칙(ISP),개방폐쇄원칙(OCP)에 도달하게된다.











