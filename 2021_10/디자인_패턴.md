# 스프링이 사랑한 디자인 패턴 

<br>

작성일자 : 2021-10-14

내용 :  스프링 입문을 위한 자바 객체 지향의 원리와 이해 서적 공부

<br><br>

## **1. 어댑터 패턴 (Adapter Pattern)**

<br>


- 어댑터 = 변환기 
  예) 전기 - 충전기 - 휴대폰

- 합성

- "호출 당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴"

- 예) JDBC 와 JRE 가 어댑터의 역할 수행

  <br>

  > 나의 질문 : 어댑터 패턴은 왜 쓰는 걸까??
  >
  > - 관계없는 인터페이스 간 같이 사용 가능
  > - 프로그램 검사 용이
  > - 클래스 재활용성 증가
  > - 기존 클래스의 소스코드를 수정해서 인터페이스에 맞추는 작업보다는 기존 클래스의 소스코드의 수정을 전혀하지 않고 타겟 인터페이스에 맞춰서 동작을 가능하게 한다.
  > - 기존 클래스 명세(사양)만 알면 얼마든지 새로운 클래스도 작성할 수 있다. 
  >   => 소스코드가 간단해지고 유지보수에 좋다

<br><br>

## **2. 프록시 패턴 (Proxy Pattern)**

<br>


- 프록시 - 대리자, 대변인

- 프록시 패턴은 실제 서비스 메서드의 반환값에 가감하는 것을 목적으로 하지 않고 제어의 흐름을 변경하거나 다른 로직을 수행하기 위해 사용한다.

- "제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴"

- 프록시 패턴은 개방폐쇄 원칙과 의존 역전 원칙이 적용된 설계패턴이다.

  <br>

  > 나의 질문 : 프록시 패턴은 왜 쓰는 걸까??
  >
  > - 프록시 패턴의 장점
  >   1. 사이즈가 큰 객체 (ex)이미지)가 로딩되기 전에도 프록시를 통해 참조 할 수 있다.
  >   2. 실제 객체의  public, protected 메서드들을 숨기고 인터페이스를 통해 노출 시킬 수 있다.
  >   3. 로컬에 있지 않고 떨어져 있는 객체를 사용할 수 있다.
  > - 프록시 패턴의 단점
  >   1. 객체 생성시 한 단계를 거치게 되므로 빈번한 객체 생성이 필요한 경우 성능이 저하 될 수 있다.

  <br>

  > 나의 질문 : 프록시 패턴은 언제 사용하는 걸까??
  >
  > - 원래 하려던 기능을 수행하며 그 외 부가적인 작업(로깅, 인증, 네트워크 통신 등)을 수행할 때 사용하면 좋다.
  > - 비용이 많이 드는 연산(DB처리, 대용량 텍스트 파일 등)을 실제로 필요한 시점에 수행하도록 해야할때 사용한다.

  

  <br><br>

## **3. 데코레이터 패턴 (Decorator Pattern)**

<br>


  - 데코레이터 패턴과 프록시 패턴 비교
    - 데코레이터 패턴  : 클라이언트가 받는 반환값에 장식을 더한다.

    - 프록시 패턴          : 제어의 흐름을 변경하거나 별도의 로직 처리를 목적으로 한다. 
          클라이언트가 받는 반환값을 축별한 경우가 아니면 변경하지 않는다.
  - 데코레이터 패튼의 주요 특징
    - 장식자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스 사용한다.
    - 장식자는 실제 서비스에 대한 참조 변수를 갖는다(합성).
    - 장식자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고 그 반환 값에 장식을 더해 클라이언트에게 돌려준다.
    - 장식자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수 있다.
- "메서드 호출의 반환 값에 변화를 주기 위해 중간에 장식자를 두는 패턴"



<br><br>

## **4. 싱글턴 패턴 (Singleton Pattern)**

<br>


- 인스턴스를 하나만 만들어서 사용하기 위한 패턴
  = 인스턴스를 하나만 생성하고 그것을 계속 사용한다.
- 싱글턴 패턴의 특징
  - new 를 실행할 수 없도록 생성자에 private 접근제어자를 지정
  - 유일한 단일 객체를 반환 할 수 있는 정적 메서드 필요 ( getInstance( ))
  - 유일한 단일 객체를 참조할 정적 참조변수가 필요하다.
  - 단일 객체는 쓰기 가능한 속성을 갖지 않는 것이 정석이다.
- 실행 T 메모리

- 단일 객체의 경우 공유 객체로 사용되기 때문에 속성을 갖지 않게한다. 단일 객체가 속성을 갖게 되면 하나의 참조변수가 변경한 단일 객체 속성이 다른 참조변수에 영향을 미치기때문이다.

  단, 읽기 전용 속성을 갖는 것은 문제가 되지 않는다. 
  단일 객체가 다른 단일 객체에 대한 참조를 속성으로 가진 것 또한 문제가 되지 않는다.
