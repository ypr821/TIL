# 프록시패턴과 데코레이터패턴 차이점

작성일자 : 2022-01-06



## 프록시 (Proxy)

- 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 한다.
- 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 **타깃(target)** 또는 **실체(real subject)**라고 한다.
- 프록시는 타깃과 같은 인터페이스를 구현하며 프록시가 타깃을 제어할 수 있는 위치에 있다.
- 프록시는 두가지 사용 목적을 가진다. 두 사용 목적 모두 프록시(대리 Object)를 두고 사용한다는 공통점이 있지만 디자인 패턴에서는 다르게 구분 할 수 있다.
  1. 클라이언트가 **타깃에 접근하는 방법 제어**한다. => **프록시 패턴**
  2. 타깃에 **부가적인 기능**을 부여한다. => **데코레이션 패턴**
     
     

- 일반적으로 사용하는 프록시라는 용어와 디자인패턴의 프록시 패턴의 구분이 필요하다.

  > 용어 프록시 : 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두분 방법을 총칭한다.
  > 프록시 패턴 : 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우 (뒤에서 다시 정리)



<br><br>

## 프록시 패턴

- 주된 사용 목적 : 클라이언트가 타깃에 접근하는 방식을 변경해준다. ( 타깃의 기능을 확장X, 추가 X )
- 사용 예시
  1. 타깃 오브젝트를 생성하기 복잡하거나 당장 필요하지 않는 경우에 필요한 시점에 오브젝트를 생성하는 편이 좋다.
     이럴때 타깃 오브젝트 객체를 생성해서 레퍼런스를 미리 넘겨주는 것이 아니라 프록시를 먼저 넘겨주고 실제 타깃을 사용하려고 시도하면, 그때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해준다.
  2. 원격 오브젝트를 이용하는 경우, 다른 서버에 존재하는 오브젝트를 사용해야한다면 원격 오브젝트에 대한 프록시를 만들어두고 클라이언트는 프록시를 로컬에 존재하는 오브젝트처럼 사용할 수 있다. 프록시는 클라이언트의 요청을 받으면 네트워크를 통해 원격의 오브젝트를 실행하고 결과를 받아서 클라이언트에게 돌려준다.



<br><br>

## 데코레이션 패턴

- 주된 사용 목적 : 부가기능을 부여하기 위해 사용한다.

- 데코레이션 패턴에서는 프록시가 꼭 한 개로 제한되지 않는다. 같은 인터페이스를 구현한 타겟과 여러개의 프록시를 사용할 수 있다.
  프록시가 여러 개면 순서를 정해서 단계적으로 위임하는 구조로 만들면된다.
  위임 방법 => 데코레이터의 다음 위임대상을 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임대상을 외부에서 런타임 시에 주입 받을 수 있도록 만들면 된다.

  

  ```java
  /* InputStream 이라는 인터페이스를 구현한 타깃 FileInputStream 에 버퍼읽기 기능을 제공하는 BufferedInputStream 라는 데코레이터 적용 */
  InputStream = new BufferedInputStream(new FileInputStream("a.txt"));
  
  ```

   

  
  
  

> 실제로 적용해서 뭔가를 만들고 싶다... 흠........



